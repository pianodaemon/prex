Notes on the implementation of user-level read-only MAP_PRIVATE
mmap(), including kernel changes to propagate fault addresses and
flags to user-level exception handlers, and library changes to support
mmap()-like semantics.

 -- Tony Garnock-Jones & Ian Johnson
    March 2011

Kernel, x86-specific:

 - An extra 2 words of stack (i.e. 4 words total) are reserved during
   setup of the exception handler stack frame. They are always filled,
   either with fault information if the exception is a page fault, or
   with zeros otherwise. context.c's context_set() has been altered to
   permit CTX_UARG to address more than one argument slot on the stack
   frame under construction.

 - The machine's error code is translated into architecture-neutral
   flags when a fault occurs.

Kernel, architecture-independent:

 - Fault information is communicated from the architecture-dependent
   trap handlers to the code responsible for filling in the exception
   handler stack frame through new arguments to the exception delivery
   mechanism. This lets us avoid ever writing fault information
   anywhere but on the stack of the active faulting thread. There's
   still a problem if a lower-numbered signal is already marked for
   delivery; a better approach might be to treat delivery of a
   fault-address-carrying SIGSEGV specially, on a totally disjoint
   code path, to avoid any opportunity for losing the
   faultaddr/faultflags. (For now, as a cheap hack, we prioritize
   SIGSEGV, so that if a SIGSEGV is pending, it will be delivered
   first.)

 - A set of architecture-neutral flags describing a page fault is
   defined in thread.h (for kernel use) and prex.h (for application
   use). One flag is particularly worth mentioning:
   PAGE_FAULT_ADDRESS_VALID is set only when the associated fault
   address is valid. In cases where SIGSEGV is delivered to a process
   by some path that does not involve a page fault, there will be no
   fault address available, and so the fault address will be passed to
   the exception handler as NULL, and the fault flags as 0.

 - The type of the exception handler function is now different. It
   takes two extra arguments: a void* and a uint32_t. When it is
   called in response to SIGSEGV, these are filled in
   appropriately. Legacy code continues to work, because C's calling
   convention causes 1-arg functions called with more than one
   argument to silently ignore the extra parameters.

 - An important bug was detected and fixed in locore.S. It is
   important to check the saved system call number *before* calling
   syscall_handler, because if syscall_handler performs an
   exception_return, the saved system call number will be overwritten
   with an essentially random value, defeating the purpose of the
   check.

POSIX emulation layer:

 - Added siginfo_t.si_addr, SEGV_MAPERR and SEGV_ACCERR.

 - On SIGSEGV, fill in si_addr and si_code based on the information
   given to the Prex exception handler. Unfortunately, a race
   condition still exists in the code in the case where multiple
   threads exist in a task with an installed handler for SIGSEGV. For
   more details, see the comment on __sig_flush_fault() in
   __exception.c.

 - Much of the required POSIX mmap() functionality remains
   unimplemented. We have only implemented PROT_READ and
   MAP_PRIVATE|MAP_FILE. POSIX mmap() requires SIGBUS to be sent in
   certain circumstances, which we have also not
   implemented. Furthermore, there is an arbitrary limit of 16
   mappings available to a process (see NMAPPINGS in mmap.c). munmap()
   is not implemented.

 - An arbitrary address of 0x60000000 is chosen to start mappings
   from. An enhanced interface to the kernel's segment maps would help
   make this less arbitrary. We rely on vm_allocate not being
   interfered with when allocating virtual address space in this
   range. (There is also a scaling issue to consider: for large maps,
   since we are allocating a segment map entry per page (!), after a
   while manipulating the segment map will get very slow.)

Test code:

 - Trivial test application, testmmap, that demonstrates that the
   basic mmap() functionality is working.

 - Trivial timing application, timemmap, that measures the latency
   accessing single bytes from pages in a mapped region, to give some
   impression of the difference between faulting in a page for the
   first time and accessing an already-faulted-in page. It also
   accesses pages from low to high and from high to low addresses, to
   show the difference between seeking and avoiding seeking.

   (In qemu, on the Pentium 4 desktop I have available to me, I see
   ~520 microseconds latency on accessing an mmap()ed page that has
   not been read into memory yet if no seek is required, and ~540
   microseconds if a seek is required. After this initial latency,
   accessing the page is as fast as any other memory access.)
